{- Все задачи в этом задании должны решаться исключительно с помощью свёрток.
Явная рекурсия не допускается. Если в решении в качестве вспомогательной
требуется стандартная функция обработки списков (помимо fold*, scan*), она
также должна реализовываться свёрткой.
Каждое решение должно сопровождаться тремя различными тестовыми примерами, которые при запуске
возвращают True, например:
f = undefined -- решение
f_test1 = f undefined == undefined -- тест 1
f_test2 = f undefined == undefined -- тест 2
f_test3 = f undefined == undefined -- тест 3 -}

-- http://www.haskell.org/ghc/docs/7.6.3/html/libraries/base-4.6.0.1/Prelude.html

{- 
1. Простейшие функции обработки списков
a) Найти сумму чётных элементов списка с целочисленными элементами.-}
f1a :: [Int] -> Int
f1a = (foldl (+) 0) . (filter even) -- решение

-- sum :: Num a => [a] -> a
-- == sum[n | n <- [1..10], even n]
f1a_test1 = f1a [1..10] == 30 -- тест 1
f1a_test2 = f1a [1..100] == 2550 -- тест 2
f1a_test3 = f1a [10..100] == 2530 -- тест 3

--b) Найти сумму и произведение элементов списка вещественных чисел.
f1b :: Real a => [a] -> (a, a)
f1b = foldl (\ (suma, multa) x -> (suma + x, multa * x) ) (0,1) -- решение

f1b_test1 = f1b [1..5] == (15, 120) -- тест 1
f1b_test2 = f1b [1..10] == (55, 3628800) -- тест 2
f1b_test3 = f1b [7..10] == (34, 5040) -- тест 3

--с) Найти среднее арифметическое элементов списка вещественных чисел (функцией length 
--пользоваться нельзя, решение должно выполняться в один проход).
f1c :: (Fractional a, Real a) => [a] -> a
f1c = (\ (suma, num) -> suma / num) . foldl (\ (suma, num) x -> 
									(suma + x, num + 1)) (0,0) -- решение

f1c_test1 = f1c [1..5] == 3.0 -- тест 1
f1c_test2 = f1c [1..10] == 5.5 -- тест 2
f1c_test3 = f1c [7..10] == 8.5 -- тест 3

--d) Найти минимальный элемент списка.
f1d :: (Ord a, Num a) => [a] -> a
f1d = foldl1 min -- решение

f1d_test1 = f1d [1..10] == 1 -- тест 1
f1d_test2 = f1d [6,5,8,3,8] == 3 -- тест 2
f1d_test3 = f1d [12,45,6] == 6 -- тест 3

--e) Найти наименьший нечётный элемент списка с целочисленными значениями 
--(дополнительным параметром функции должно быть значение, возвращаемое по умолчанию).
f1e :: Int -> [Int] -> Int
f1e znach = foldl (\ acc x -> if (x < acc && odd x) || (acc == znach && odd x) then x 
		else acc) znach -- решение

f1e_test1 = f1e 0 [1..10] == 1 -- тест 1
f1e_test2 = f1e 0 [6,5,8,4,8] == 5 -- тест 2
f1e_test3 = f1e 0 [12,45,6] == 45 -- тест 3

{-
2. Свёртки, формирующие списки
a) Сформировать список, содержащий каждый второй элемент исходного.-}

-- реверс списка
reverse1 = foldl (flip (:)) []

f2a :: [a] -> [a]
f2a = reverse1 . snd . foldl additionalFunc1 (False, [])
	where
		additionalFunc1 (flag, acc) x
			| flag = (not flag, x:acc)
			| otherwise = (not flag, acc) -- решение

f2a_test1 = f2a [1] == [] -- тест 1
f2a_test2 = f2a [1..3] == [2] -- тест 2
f2a_test3 = f2a [1..10] == [2,4,6,8,10] -- тест 3

--b) Сформировать список, содержащий первые n элементов исходного.

f2b :: Int -> [a] -> [a]
f2b n = reverse1 . snd . foldl (additionalFunc2) (0, [])
	where
		additionalFunc2 (count, acc) x
			| count < n = (count + 1, x:acc)
			| otherwise = (count, acc) -- решение

f2b_test1 = f2b 1 [1..10] == [1] -- тест 1
f2b_test2 = f2b 5 [1..10] == [1..5] -- тест 2
f2b_test3 = f2b 10 [1..10] == [1..10] -- тест 3

--c) Сформировать список, содержащий последние n элементов исходного.

f2c :: Int -> [a] -> [a]
f2c n = snd . foldr (additionalFunc3) (0, [])
	where
		additionalFunc3 x (count, acc)
			| count < n = (count + 1, x:acc)
			| otherwise = (count, acc) -- решение

f2c_test1 = f2c 1 [1..10] == [10] -- тест 1
f2c_test2 = f2c 5 [1..10] == [6..10] -- тест 2
f2c_test3 = f2c 10 [1..10] == [1..10] -- тест 3

--d) Сформировать список, содержащий все элементы исходного списка, большие левого соседа.

--e) Сформировать список, содержащий все локальные минимумы исходного списка.

f2e :: Ord a => [a] -> [a]
f2e (x:y:z) = reverse1 $ third $ foldl additionalFunc4 (x, y, []) z
	where
		third (_, _, three) = three
		additionalFunc4 (x1, y1, acc) e
			| e < y1 || x1 < y1 = (y1, e, acc)
			| otherwise = (y1, e, y1:acc) -- решение
f2e (x:z) = []

f2e_test1 = f2e [1..10] == [] -- тест 1
f2e_test2 = f2e [1,2,3,2,4,1,5] == [2,1] -- тест 2
f2e_test3 = f2e [1,2,3,4,5,6,3,7] == [3] -- тест 3

--f) Дана строка, содержащая слова, разделённые одним или несколькими пробелами. 
--Сформировать список слов этой строки.

f2f :: String -> [String]
f2f = snd . foldr additionalFunc5 ([], []) . (' ':)
	where
		additionalFunc5 x (wrd, acc)
			| x /= ' ' = (x : wrd, acc)
			| x == ' ' && (wrd /= "") = ([], wrd : acc)
			| otherwise = ([], acc) -- решение

f2f_test1 = f2f " " == [] -- тест 1
f2f_test2 = f2f "aaa bbb ccc" == ["aaa", "bbb", "ccc"] -- тест 2
f2f_test3 = f2f "abcbb a-b-c" == ["abcbb", "a-b-c"] -- тест 3

--g) Разбить список на непересекающиеся подсписки длиной n элементов.

-- возвращаем длину списка 
length1 = foldl (\ acc x -> acc +1) 0

f2g :: Int -> [a] -> [[a]]
f2g n = reverse1 . snd . foldl additionalFunc6 ([], [])
	where
		additionalFunc6 (y, acc) x
			| (< (n-1)) $ length1 y = (x : y, acc)
			| otherwise = ([], reverse1 (x : y) : acc) -- решение

f2g_test1 = f2g 3 [1..10] == [[1..3],[4..6],[7..9]] -- тест 1
f2g_test2 = f2g 5 [1..10] == [[1..5],[6,10]] -- тест 2
f2g_test3 = f2g 10 [1..10] == [[1..10]] -- тест 3

--h) Разбить список на подсписки длиной n элементов с перекрывающейся 
--частью в k элементов (k < n).

--k) Сформировать список, содержащий все начальные элементы списка, 
--удовлетворяющие заданному предикату.

f2k :: (a -> Bool) -> [a] -> [a]
f2k uslovie = reverse1 . snd . foldl additionalFunc7 (True, [])
	where
		additionalFunc7 (flag, acc) x
			| flag && uslovie x = (True, x:acc)
			| otherwise = (False, acc) -- решение

f2k_test1 = f2k (\ x -> x == 1) [1,2,3,4,5,6] == [1] -- тест 1
f2k_test2 = f2k (\ x -> x < 2) [1,1,1,4,5,6] == [1,1,1] -- тест 2
f2k_test3 = f2k (\ x -> odd x) [1,1,1,4,5,6] == [1,1,1] -- тест 3

--l) Повторить каждый элемент списка заданное количество раз.

f2l :: Int -> [a] -> [a]
f2l n = foldr additionalFunc8 []
	where
		additionalFunc8 x acc = (newadd n x) ++ acc
			where
				newadd num a = foldl (\ acc x -> a:acc) [] [0..num] -- решение

f2l_test1 = f2l 0 [1..5] == [1..5] -- тест 1
f2l_test2 = f2l 1 [1..5] == [1,1,2,2,3,3,4,4,5,5] -- тест 2
f2l_test3 = f2l 5 [1] == [1,1,1,1,1,1] -- тест 3

--m) Удалить из списка повторяющиеся подряд идущие элементы.

f2m :: Eq a => [a] -> [a]
f2m = reverse1 . foldl additionalFunc9 []
	where
		elem1 b = foldl (\ acc c -> (c==b) || acc) False
		additionalFunc9 acc a
			| elem1 a acc = acc
			| otherwise = a:acc -- решение

f2m_test1 = f2m "11223344" == "1234" -- тест 1
f2m_test2 = f2m "aaaaaaaaaaa" == "a" -- тест 2
f2m_test3 = f2m "aaabbbccc" == "abc" -- тест 3

--n) Даны два списка одинаковой длины. Сформировать список, состоящий из результатов 
--применения заданной функции двух аргументов к соответствующим элементам исходных списков.

{-
3. Использование свёртки как носителя рекурсии (для запуска свёртки можно использовать список типа [1..n]).
a) Найти сумму чисел от a до b.-}

f3a :: (Enum a, Num a) => a -> a -> a
f3a a b = foldl (\ acc x -> x + acc) 0 [a..b] -- решение

f3a_test1 = f3a 1 5 == sum [1..5]  -- тест 1  15
f3a_test2 = f3a 1 10 == sum [1..10]  -- тест 2  55
f3a_test3 = f3a 1 100 == sum [1..100]  -- тест 3  5050

--b) Найти сумму факториалов чисел от a до b 
--(повторные вычисления факториалов не допускаются).

--с) Сформировать список из первых n чисел Фибоначчи.

-- map f xs is the list obtained by applying f to each element of xs
map1 func = foldr (\ x acc -> (func x):acc) []

f3c :: (Enum a, Num a) => a -> [Integer]
f3c n = map1 fst $ scanl addFunc1 (0,1) [2..n]
	where
		addFunc1 (prev, cur) x = (cur, cur + prev) -- решение

f3c_test1 = f3c 1 == [0] -- тест 1
f3c_test2 = f3c 5 == [0,1,1,2,3] -- тест 2
f3c_test3 = f3c 10 == [0,1,1,2,3,5,8,13,21,34] -- тест 3

--d) Пользуясь рядом Тейлора, вычислить значение синуса заданного числа x 
--(использовать n слагаемых).

--e) Проверить, является ли заданное целое число простым.

f3e :: Integral a => a -> Bool
f3e x = foldl (\ acc n -> (x `mod` n /=0) && acc) True [2..(x-1)] -- решение

f3e_test1 = f3e 1 == True  -- тест 1
f3e_test2 = f3e 4 == False  -- тест 2
f3e_test3 = f3e 13 == True  -- тест 3

{-
4. Решить задачу о поиске пути с максимальной суммой в треугольнике (см. лекцию 3) при условии,
что необходимо дополнительно найти сам путь (к примеру, в виде закодированных направлений спуска:
0 - влево, 1 - вправо). В решении допускается использование любых стандартных функций.
5. Пусть числовые матрицы представлены списками строк. Реализовать следующие функции:
1) транспонирование матрицы;
2) сумма двух матриц;
3) произведение двух матриц.
6. Реализовать левую свёртку, пользуясь правой. Проанализировать поведение собственной реализации
на бесконечных списках и сравнить его с поведением оригинальной foldl.
-}
