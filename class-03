{-
Явная рекурсия в решениях хотя и допускается, но не приветствуется. Старайтесь обходиться стандартными
функциями, используя при этом создание функций «на лету». Пытайтесь максимально упростить уже написанные
решения, применяя подходящие функции из модуля Data.List и любых других модулей. Перед выполнением заданий
изучите примеры из лекции по функциям высшего порядка. 
-}
-- документация
-- http://www.haskell.org/ghc/docs/7.6.3/html/libraries/base/Data-List.html
import Data.List
import Data.Char
import Numeric
{-
 1. Простейшие задачи на применение функций map и filter.
 1.1 Преобразовать данный список целых чисел следующим образом:-}
--  a) увеличить все его элементы в два раза;
map1 :: Integral a => [a] -> [a]
map1 [] = []
map1 (x:xs) = (2*x) : map1 (xs)
--  b) увеличить все его элементы с четными значениями в два раза;
map2 :: Integral a => [a] -> [a]
map2 [] = []
map2 [x] = [x]
map2 (x:y:xs) = x : (2*y) : map2 (xs)
--  с) обнулить все его элементы с нечетными значениями;
map3 :: Integral a => [a] -> [a]
map3 [] = []
map3 [x] = [0]
map3 (x:y:xs) = 0 : y : map3 (xs)
--  d) удалить из него элементы, большие заданного числа k;
map4 :: (Integral a, Ord a) => [a] -> a -> [a]
map4 [] k = []
map4 (x:xs) k
	| x > k = map4 (xs) k
	| otherwise = x : map4 (xs) k
--  e) отфильтровать его, оставив в списке только отрицательные числа;
map5 :: Integral a => [a] -> [a]
map5 [] = []
map5 (x:xs) 
	| x >= 0 = map5 (xs)
	| otherwise = x : map5 (xs)
--  f) удалить из него все положительные чётные числа.
map6 :: Integral a => [a] -> [a]
map6 [] = []
map6 (x:xs) 
	| x > 0 = map6 (xs)
	| otherwise = x : map6 (xs)

--f11a :: Integral a => [a] -> [a]
--f11a = map undefined

{-
 1.2 Дан список декартовых координат точек на плоскости (пар вещественных чисел).
     Преобразовать его следующим образом:
  a) отфильтровать список так, чтобы в нём остались точки из заданной координатной четверти;
-}
type Point = (Double, Double)

map_of_maps :: [Point] -> Int -> [Point]
map_of_maps [] k = []
map_of_maps xs k 
	| k == 1 = filter (\(x,y) -> (x>0) && (y>0)) xs
	| k == 2 = filter (\(x,y) -> (x<0) && (y>0)) xs
	| k == 3 = filter (\(x,y) -> (x>0) && (y<0)) xs
	| k == 4 = filter (\(x,y) -> (x<0) && (y<0)) xs
	| otherwise = error "error! must be 0 < k < 5"
-- b) преобразовать декартовы координаты в полярные.
map_coord :: [Point] -> [Point]
map_coord xs = map(\(x,y) -> if sqrt(x*x + y*y) == 0 then (x,y) else (sqrt(x*x + y*y), asin$ y/sqrt(x*x + y*y))) xs

{-
 1.3 Дан список слов.
  a) Преобразовать все слова к верхнему регистру.-}
word_list1 :: [String] -> [String]
word_list1 [] = []
word_list1 wordlist = map(\list -> map(\l -> toUpper l) list) wordlist
--  b) Извлечь из него подсписок слов заданной длины.
word_list2 :: [String] -> Int -> [String]
word_list2 [] k = []
word_list2 wordlist 0 = []
word_list2 wordlist k = filter(\list -> length list == k) wordlist
--  c) Извлечь из него подсписок слов, начинающихся с заданной буквы.
word_list3 :: [String] -> Char -> [String]
word_list3 [] ch = []
word_list3 wordlist ch = filter(\list -> head list == ch) wordlist

--f13a :: [String] -> [String]
--f13a = map undefined

{-
2. Формирование числовых последовательностей (iterate).
 a) Список натуральных чисел, начиная с 0.-}
nats :: [Integer]
nats = iterate (+1) 0
 -- b) Список чётных чисел.
evens :: [Integer]
evens = iterate (+2) 0
 --c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
lists :: Int -> [Double]
lists k = take k$ iterate ((/2).(+1)) 1
 --d) Список символов английского алфавита.
letters :: [Char]
letters = take 26 $ iterate (chr.(+1).ord) 'a'
 --e) Список строк, представляющих n-значные двоичные числа.
list_of_lists :: Int -> [String]
list_of_lists k = undefined

-- 3. Группировка списков.
--  a) Дан список символов. Сгруппировать подряд идущие символы по принципу: цифры — не цифры — ...
-- ['f','u','n','2','4','n','4','5'] -> ["fun", "24", "n", "45"]
f3a :: [Char] -> [String]
f3a sx = groupBy(\x y -> (isDigit x && isDigit y) || (isLetter x && isLetter y)) sx
--  b) Дан список пар вещественных чисел (координат точек на плоскости). Сгруппировать подряд идущие
--   координаты точек, лежащие в одной координатной четверти.
f3b :: [Point] -> [[Point]]
f3b p = groupBy (\x y -> func_point x == func_point y) p
	where 
		func_point :: Point -> Int
		func_point (x,y)
			| x>0 && y>0 = 1
			| x<0 && y>0 = 2
			| x<0 && y<0 = 3
			| otherwise = 4
-- c) Дан список и ненулевое натуральное число n. Разбить список на подсписки длиной n каждый.
--     Последний подсписок может содержать менее n элементов.
f3c :: [a] ->Int -> [[a]]
f3c list n = map (take n) $ takeWhile (not.null) $iterate (drop n) list
--  d) Дан список и ненулевые натуральные числа n и m. Разбить список на перекрывающиеся подсписки
--     длиной n элементов со сдвигом относительно предыдущего подсписка на m элементов.
-- f3d [1,2,3,4,5,6,7] 3 2 -> [[1,2,3],[3,4,5],[5,6,7],[7]]
f3d :: [a] -> Int -> Int -> [[a]]
f3d xs n m = map (take n) $ takeWhile (not.null) $iterate (drop m) xs
--  e) Дан список. Определить длину самого длинного подсписка, содержащего подряд идущие одинаковые элементы.

-- Должно быть True
-- true
test_f3d = f3d [1..10] 4 2 == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

{-
4. Разные задачи.
 a) Дан текст в виде строки символов, содержащий среди прочего числовые данные. Посчитать количество
    всех упоминающихся в тексте чисел.-}
f4a :: String -> Int
f4a str = length $ filter (\x-> isDigit x) str
-- b) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату, в указанном промежутке
--    (например: все чётные от 1 до 106).
f4b :: Num a => a -> Int -> a
f4b fib l = sum $ take l $ map fst $ iterate (\(x,y) -> (y,x+y) ) (fib,fib+1)
-- c) Дана строка текста и число n. Сформировать список, содержащий n самых часто используемых
--    в строке символов.
-- d) Дан список чисел. Сформировать список локальных максимумов исходного списка. Локальным максимумом
--    называется элемент, больший своих соседей.
-- e) Дан список. Продублировать все его элементы.
f4e ::[a]->[a]
f4e list = concat $ map (\x->[x,x]) list
